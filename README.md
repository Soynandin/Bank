# BananaBank

**BananaBank** √© uma aplica√ß√£o simples para gerenciamento de usu√°rios. Permite criar, atualizar, mostrar e excluir usu√°rios.

---

## Rotas da API
Para o consumo com **GraphQL** todos os dados s√£o manipulados atrav√©s de queries (consultas) e mutations (muta√ß√µes) no formato GraphQL.

Endpoint: `POST /graphql`

Para testar as rotas, voc√™ pode usar a interface interativa GraphiQL para as consultas GraphQL: `http://localhost:4000/graphiql`

Para o consumo **Rest** as rotas s√£o:

- `GET /api`: Retorna uma mensagem de boas-vindas.
- `GET /api/users/:id`: Exibe os dados de um usu√°rio espec√≠fico pelo `id`.
- `POST /api/users`: Cria um novo usu√°rio.
- `PATCH /api/users/:id`: Atualiza parcialmente os dados de um usu√°rio.
- `PUT /api/users/:id`: Atualiza completamente os dados de um usu√°rio.
- `DELETE /api/users/:id`: Exclui um usu√°rio.

---

## Testando as rotas

Para visualizar todas as rotas da API, basta rodar o seguinte comando:

```sh
mix phx.routes
```

---

## User

1. **Atributos do Usu√°rio**
  - **`id`** (`id`): Identificador √∫nico do usu√°rio.
  - **`first_name`** (`string`): Primeiro nome do usu√°rio.
  - **`last_name`** (`string`): Sobrenome do usu√°rio.
  - **`email`** (`string`): Endere√ßo de e-mail do usu√°rio.
  - **`password`** (`string`, virtual): Senha do usu√°rio (n√£o armazenada diretamente, apenas usada para gerar o `password_hash`).
  - **`password_hash`** (`string`): Hash da senha do usu√°rio armazenado no banco de dados.
  - **`document`** (`string`): Documento do usu√°rio (CPF ou CNPJ).
  - **`role`** (`string`): Papel do usu√°rio no sistema. Pode ser:
  - **`inserted_at`** (`timestamp`): Data de cria√ß√£o do usu√°rio.
  - **`updated_at`** (`timestamp`): Data da √∫ltima atualiza√ß√£o do usu√°rio.

2. **Regras de Neg√≥cio e Valida√ß√µes**

  - O campo `email` deve ser √∫nico e seguir um formato v√°lido.
  - O campo `document` deve ser um CPF ou CNPJ v√°lido.
  - A senha do usu√°rio √© criptografada usando `Pbkdf2`.
  - A role do usu√°rio deve ser uma das op√ß√µes permitidas (`client`, `agency`, `admin`).
  - Apenas administradores podem modificar a role para `admin`.

---

### üìù Como Funciona

O gerenciamento de usu√°rios na aplica√ß√£o segue o modelo de **GraphQL** para interagir com os dados. Cada opera√ß√£o de cria√ß√£o, leitura, atualiza√ß√£o e exclus√£o √© tratada por resolvers espec√≠ficos. Aqui est√° um detalhamento de como cada opera√ß√£o funciona, incluindo valida√ß√µes e tratamentos de erro:

#### 1. **Listar Usu√°rios**
Quando uma requisi√ß√£o de listagem de usu√°rios √© feita via **GraphQL**, o resolver `UserResolver.list_users/3` √© chamado. Esse resolver invoca o m√≥dulo **`Users.List`** para buscar todos os usu√°rios com os par√¢metros de **pagina√ß√µes** e **ordena√ß√£o**. Caso nenhum atributo (ou um atributo inv√°lido) seja passado por par√¢metro em **`order_by`**, o atributo **`first_name`** ser√° definido por padr√£o e utilizado. A consulta √© feita atrav√©s do Ecto com os seguintes par√¢metros:
- **`limit`**: Limite de usu√°rios retornados (padr√£o: 10).
- **`offset`**: Deslocamento de resultados para pagina√ß√£o (padr√£o: 0).
- **`order_by`**: Coluna para ordena√ß√£o (padr√£o: "first_name").
- **`direction`**: Dire√ß√£o da ordena√ß√£o (padr√£o: "asc").

#### **Modelo Graphiql**
```graphql
query {
  users(limit: 5, offset: 0, orderBy: "first_name", direction: "asc") {
    id
    firstName
    lastName
    email
    document
    role
  }
}
```

#### 2. **Obter Usu√°rio**
Para buscar um usu√°rio espec√≠fico, o resolver **`UserResolver.get_user/3`** √© invocado. Este resolver chama o m√≥dulo **`Users.Get`**, que tenta buscar o usu√°rio no banco com base no **ID** fornecido. O processo de busca segue o seguinte fluxo:
- Se o ID for inv√°lido (n√£o num√©rico), retorna um erro: `"Invalid ID format"`.
- Se o usu√°rio n√£o for encontrado, retorna um erro 404: `"User not found"`.
- Caso contr√°rio, retorna os dados do usu√°rio solicitado.

#### **Modelo Graphiql**
```graphql
query {
  user(id: 1) {
    id
    firstName
    lastName
    email
    document
    role
  }
}
```

#### 3. **Criar Usu√°rio**
Para criar um usu√°rio, o resolver **`UserResolver.create_user/3`** chama o m√≥dulo **`Users.Create`**, que aplica as valida√ß√µes usando o **Changeset**:
- Valida se todos os par√¢metros obrigat√≥rios est√£o presentes: `first_name`, `last_name`, `email`, `password`, `document` e `role`.
- O campo `email` √© validado com um formato espec√≠fico (example@example.example) e deve ser **√önico**.
- O campo `role` √© validado para aceitar apenas os valores "client", "agency" ou "admin".
- O campo `document` √© validado para garantir que seja um CPF ou CNPJ v√°lido.
- A senha √© criptografada utilizando **Pbkdf2** antes de ser armazenada no banco de dados.
- O campo `document` √© validado para garantir que seja um CPF ou CNPJ v√°lido, utilizando a biblioteca **Brcpfcnpj**. Caso o documento n√£o seja v√°lido, √© retornado um erro."
- Caso algum erro de valida√ß√£o ocorra, ele √© retornado como uma mensagem clara de erro com os campos falhos.

#### **Modelo Graphiql**
```graphql
mutation {
  createUser(
    firstName: "Jo√£o"
    lastName: "Silva"
    email: "joao.silva@example.com"
    password: "senha123"
    document: "12345678900"
    role: "client"
  ) {
    id
    firstName
    lastName
    email
    document
    role
  }
}
```


#### 4. **Atualizar Usu√°rio**
Para atualizar um usu√°rio, o resolver **`UserResolver.update_user/3`** chama o m√≥dulo **`Users.Update`**. O processo de atualiza√ß√£o segue os seguintes passos:
- Verifica se o usu√°rio existe. Se n√£o for encontrado, retorna erro: `"User not found"`.
- Valida se o **usu√°rio atual** (representado por `current_user`) tem permiss√£o para atualizar o usu√°rio desejado:
  - Administradores (`role: "admin"`) podem alterar qualquer usu√°rio, incluindo a si mesmos.
  - Clientes ou Ag√™ncias podem alterar apenas a si mesmos, e n√£o podem modificar seu pr√≥prio papel para "admin".
  - Se o **usu√°rio atual** n√£o tem permiss√£o para a a√ß√£o, um erro de "Unauthorized to update this user" √© retornado.
- O usu√°rio s√≥ √© atualizado caso esteja logado, isto √©, se o token jwt estiver ativo no **Header**.
- Se a altera√ß√£o for permitida, um **Changeset** √© aplicado com os campos `first_name`, `last_name`, `email`, `document` e `role`, sendo que `role` n√£o pode ser alterado para "admin" por clientes ou ag√™ncias.
- Uma mensagem de erro ir√° ser retornada se houver erros de valida√ß√£o, como:
  - Email j√° cadastrado.
  - Cpf ou cnpj inv√°lido.
  - Campo vazio
  - Id inv√°lido | inexistente
  - Regras do campo `role` n√£o obedecidas
- Se a atualiza√ß√£o for bem-sucedida, os dados do usu√°rio atualizado s√£o retornados.

#### **Modelo Graphiql**
```graphql
mutation {
  updateUser(
    id: 1
    firstName: "Carlos"
    lastName: "Souza"
    email: "carlos.souza@example.com"
    document: "12345678900"
    role: "client"
  ) {
    id
    firstName
    lastName
    email
    document
    role
  }
}
```

#### 5. **Excluir Usu√°rio**
Para excluir um usu√°rio, o resolver **`UserResolver.delete_user/3`** invoca o m√≥dulo **`Users.Delete`**:
- A opera√ß√£o tenta excluir o usu√°rio pelo **ID**.
- Se o usu√°rio n√£o for encontrado, retorna um erro: `"Failed to delete user"`.
- Se a exclus√£o for bem-sucedida, retorna uma mensagem de sucesso: `"User deleted successfully"`.

#### **Modelo Graphiql**
```graphql
mutation {
  deleteUser(id: 1) {
    message
  }
}
```

#### 6. **Login**
Para realizar o login, o resolver **`AuthResolver.login/3`** √© utilizado:
- O **email** e **password** s√£o passados como par√¢metros para a fun√ß√£o `authenticate/2` no m√≥dulo **`Guardian`**.
- O m√©todo **`authenticate`** verifica se o usu√°rio existe e se a senha fornecida corresponde √† senha armazenada no banco de dados (verificando com `Pbkdf2.verify_pass`).
- Se as credenciais forem v√°lidas, dois tokens s√£o gerados:
  - **Access Token** com validade de 15 minutos.
  - **Refresh Token** com validade de 7 dias.
- O retorno √© um objeto contendo os tokens gerados.
- Se as credenciais forem inv√°lidas, um erro √© retornado com a mensagem apropriada.

#### **Modelo Graphiql**
```graphql
mutation {
  login(email: "user@example.com", password: "password123") {
    accessToken
    refreshToken
  }
}

```
#### 7. **Refresh Token**
O resolver **`AuthResolver.refresh_token/3`** √© utilizado para gerar um novo **access token** usando o **refresh token**:
- O **refresh token** fornecido √© decodificado e verificado atrav√©s do m√©todo **`Guardian.decode_and_verify`**.
- Se o **refresh token** for v√°lido e o usu√°rio correspondente for encontrado, um novo **access token** √© gerado com a validade de 15 minutos.
- O retorno √© o novo **access token**.
- Caso o **refresh token** seja inv√°lido ou a verifica√ß√£o falhe, um erro de "Invalid refresh token" √© retornado.

#### **Modelo Graphiql**
```graphql
mutation {
  refresh_token(refresh_token: "refresh_token_aqui") {
    access_token
  }
}
```

#### 9. **Logout**
O resolver **`AuthResolver.logout/3`** permite que o usu√°rio fa√ßa logout:
- O **token** presente no contexto (geralmente o **access token**) √© passado para o m√©todo **`Guardian.revoke`**, que revoga o token.
- Se a revoga√ß√£o for bem-sucedida, uma mensagem de sucesso √© retornada.
- Caso haja algum erro ao tentar revogar o token, uma mensagem de erro √© retornada.

#### **Modelo Graphiql**
```graphql
mutation {
  logout {
    message
  }
}
```
### **Adendo sobre a autentica√ß√£o de usu√°rios**
O padr√£o √© enviar o access token no cabe√ßalho das requisi√ß√µes subsequentes para autenticar o usu√°rio. A chave no cabe√ßalho deve ser Authorization e o valor deve ser o token, precedido pela palavra Bearer, assim:
```http
Authorization: Bearer <access_token>
```

  - **Login**:
    - Quando o usu√°rio realiza o login com o email e password, o servidor gera dois tokens: um access token e um refresh token.
    - O access token √© utilizado para autenticar o usu√°rio em futuras requisi√ß√µes. Ap√≥s o login bem-sucedido, o access token deve ser enviado no cabe√ßalho das requisi√ß√µes subsequentes para acessar recursos protegidos.
    - O refresh token √© utilizado para gerar um novo access token quando o antigo expirar, mas ele n√£o precisa ser enviado no cabe√ßalho em requisi√ß√µes subsequentes, apenas quando o access token expirar e voc√™ for renovar.

  - **Refresh Token**:
    -Quando o access token expira, o cliente pode enviar o refresh token no corpo da requisi√ß√£o para obter um novo access token.
    - Embora o refresh token seja enviado no corpo da requisi√ß√£o, o access token gerado deve ser inclu√≠do no cabe√ßalho de futuras requisi√ß√µes para autentica√ß√£o.

  - **Logout**:
    - O logout revoga o access token atual, e para isso, o access token precisa ser enviado no cabe√ßalho da requisi√ß√£o para que o servidor possa identificar qual token revogar.


### **Tratamento de Erros**
Em todas as opera√ß√µes, caso ocorra um erro, a aplica√ß√£o garante que a resposta seja informativa:
- **Erro de ID inv√°lido**: Caso um ID fornecido n√£o seja um n√∫mero v√°lido, o sistema retornar√° `"Invalid ID format"`.
- **Erro de usu√°rio n√£o encontrado**: Se a busca ou exclus√£o de um usu√°rio n√£o encontrar o usu√°rio no banco, retornar√° `"User not found"`.
- **Erros de valida√ß√£o**: Se os dados enviados para a cria√ß√£o ou atualiza√ß√£o de um usu√°rio n√£o forem v√°lidos, o sistema retornar√° uma mensagem com detalhes sobre o erro em cada campo espec√≠fico.

### **Adendo para o password**
#### Din√¢mica de Senha

A aplica√ß√£o utiliza o algoritmo **Pbkdf2** para armazenar as senhas de forma segura. A senha do usu√°rio n√£o √© armazenada diretamente no banco de dados; em vez disso, √© gerado um **hash** da senha.

- O campo `password` √© virtual e usado para receber a senha.
- O campo `password_hash` armazena o **hash** da senha no banco de dados.

Durante a cria√ß√£o ou atualiza√ß√£o do usu√°rio, a senha fornecida √© processada e convertida em um **hash** seguro utilizando **Pbkdf2**. O hash gerado √© armazenado no banco de dados, nunca a senha em texto claro.

---

### Banco de Dados

A aplica√ß√£o utiliza o **Ecto** para interagir com o banco de dados, usando o **PostgreSQL** como sistema de gerenciamento de banco de dados. O Ecto √© respons√°vel por fornecer uma camada de abstra√ß√£o sobre o banco, facilitando opera√ß√µes como inser√ß√£o, consulta, atualiza√ß√£o e exclus√£o de dados. Al√©m disso, o Ecto lida com migra√ß√µes para criar e modificar tabelas, mantendo a estrutura do banco consistente ao longo do tempo.

#### Estrutura do Banco de Dados

- **BananaBank.Repo**: √â o m√≥dulo principal que interage diretamente com o banco de dados. Ele utiliza o adaptador do **Ecto.Adapters.Postgres** para conectar-se ao banco de dados PostgreSQL. O m√≥dulo √© respons√°vel por configurar as conex√µes e executar as consultas Ecto.
